<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Estructura de Datos</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<!--<link rel="stylesheet" href="css/theme/black.css" id="theme">-->
		<link rel="stylesheet" href="css/theme/league.css">
		<link rel="stylesheet" href="?transition=convex#/transitions">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- ESTA ES LA PRIMERA DIAPOSITIVA -->
				<section>
					<h1>Algoritmos de Ordenamiento</h1>
					
				</section>
				<section>
					
					<h3>TP 2 - Estructura de Datos</h3>
					<img data-src="Imagenes/Logo.png" width="200" height="200">
					
					<p>
						<small>Created by <a href="">Grupo 11</a></small>
					</p>
				</section>
				
				

				
				<section>
					<h2>Comparativa entre los distintos algoritmos de ordemaniento</h2>
				</section>

				<section>
					<h2>
						Los algoritmos que se analizarán serán:
					</h2>
					<h3>
						Burbuja (Bubble Sort)
					</h3>
					<h3>
						Inserción (Insertion Sort)
					</h3>
					<h3>
						Mezclas (Merge Sort)
					</h3>
					<h3>
						Rápido (Quicksort)
					</h3>
					<h3>
						Selección (Selection Sort)
					</h3>
				</section>
				<section>
				<section>
				<h3>Algaritmo de Burbuja</h3>
				<p>La forma en que funciona este algoritmo es recorriendo la lista y comparando los valores entre si.</p>
				<p>Por ejemplo:</p>
				<p>Compara el valor de la posicion 0 con la 1, si el valor de la posicion 1 es menor que el valor de la posicion 0 se intercambian los valores entre si. Si el valor de la posicion 0 es menor no se intercambian</p>
				<p>Despues compara el valor de la posicion 1 con el valor de la posicion 2 y realiza el mismo proceidmiento anterior.</p>
				<p>Por lo tanto el algoritmo recorrera la lista tantas veces como se anecesario hasta ordenar todos los valores.</p>

				</section>
				<section>
					<p>Se le llama algoritmo de burbuja porque los numeros mas pequeños burbujean a la superficie que seria lo mas cerca de la posicion 0</p>
					<img src="imagenes/Burbuja.jpg" width="330" height="400">
				</section>
				<section>
					<p>Primer recorrido a toda la lista</p>
					<img src="imagenes/PrimeraPasadaBurbuja.jpg" width="330" height="400">
				</section>
				<section>
					<p>Segundo recorrido a toda la lista</p>
					<img src="imagenes/SegundaPasadaBurbuja.jpg" width="330" height="400">
				</section>
				<section>
					<p>Tercer recorrido a toda la lista</p>
					<img src="imagenes/TerceraPasadaBurbuja.jpg" width="330" height="400">
				</section>
				<section>
					<p>Cuarto recorrido a toda la lista</p>
					<img src="imagenes/CuartaPasadaBurbuja.jpg" width="330" height="300">
				</section>
				<section>
					<p>Quinto recorrido a toda la lista</p>
					<img src="imagenes/QuintaPasadaBurbuja.jpg" width="330" height="200">
				</section>
				<section>
					<h2>Rendimiento del algoritmo</h2>
					<p>Formula para calcular el rendimento del algoritmo:</p>
					<img src="imagenes/FormulaBurbuja.jpg" width="200" height="100">
					<p>Siendo n la cantidad de registros de la lista. Por lo que para el caso mas desfaborable, si tenemos una lista ordenada de forma descendente. La formula en este casi seria:</p>
					<img src="imagenes/FormulaDesfBurbuja.jpg" width="200" height="70">
				</section>
				<section>
					<p>Grafica de comportamiento:</p>

					<img src="imagenes/GraficaBurbuja.jpg" width="600" height="400">
					
				</section>
				</section>
				<section>
				<section>
				<h3>Algaritmo de Inserción</h3>
				<p>Se parte de un elemento incial <em>k</em> despues se toma el elemento <em>k+1</em> y se lo compara con todos los elementos de ya ordenados, osea <em>k</em>, y se detiene cuando encuentra un numero menor o cuando ya no haya elementos. En ese punto se inserta el elemento <em>k+1</em> y pasa al listado de <em>k.</em></p>
				

				</section>
				<section>
					<p>Ejemplo en el que el elemento <em>k+1</em> es el numero 31. La lista de elementos ordenados <em>k</em> son los numeros 17, 26, 54, 77, 93.</p>
					<img src="imagenes/OrdenamientoInsercion.jpg" width="450" height="400">
				</section>
				<section>
					<h2>Rendimiento del algoritmo</h2>
					<p>En el caso de que los elementos se encuentren ordenados el algoritmo realizará <em>n</em> comparaciones, siendo <em>n</em> el numeros de elementos de la lista:</p>

					<img src="imagenes/CasoOptimoInsercion.jpg" width="100" height="50">
					<p>En el caso que todos los elementos de la lista esten ordenados de forma descendente la formula para el rendimiento del algoritmo es:</p>
					<img src="imagenes/PeorCasoInsercion.jpg" width="100" height="50">
				</section>
				<section>
					<p>Grafica de comportamiento:</p>

					<img src="imagenes/GraficaInsercion.jpg" width="600" height="400">
					
				</section>
				</section>
				<section>
				<section>
				<h3>Algaritmo de Mezcla</h3>
				<p>Esta basado en la tecnica de divide y venceras.</p>
				<p>
						Es un algoritmo recursivo que divide continuamente una lista por la mitad. 
						</p>
						<p>
							Si la lista está vacía o tiene un solo ítem se ordena por definición (el caso base). Si la lista tiene más de un ítem dividimos la lista e invocamos recursivamente un ordenamiento por mezcla para ambas mitades. 

						</p>
						
				

				</section>
				<section>
					<p>
							Una vez que las dos mitades están ordenadas se realiza la operación fundamental denominada mezcla. La mezcla es el proceso de tomar dos listas ordenadas más pequeñas y combinarlas en una sola lista nueva y ordenada.

						</p>
				</section>
				<section>
					
					<p>
						
						Partimos de una lista de 9 numeros enteros y se va dividiendo por la mitad hasta obtener una lista de un solo numero.
					</p>
					<img src="imagenes/Division.png" width="500" height="400">
				</section>
				<section>
					
					<p>
						
						Cuando ya tenemos dos listas ordenadas comenzamos a mezclarlas para obtener una lista nueva y ordenada.
					</p>
					<p>Para realizar la division de la lista se utiliza una funcion recursiva hasta obtener una lista de un solo numero.</p>
					<img src="imagenes/Mezcla.png" width="500" height="400">
				</section>
				<section>
					<h2>Rendimiento del algoritmo</h2>
					<p>Como no es necesaria la busqueda en toda la lista sino en pociones mas pequeñas se dice que la formula de este algoritmo es:</p>

					<img src="imagenes/FormulaMezcla.jpg" width="100" height="50">
					<p>Este algoritmo es utilizado por Perl 5.8 por defecto y el ordenamiento de Arrays en Java se realiza con este mismo algoritmo.</p>
					
				</section>
				<section>
					<p>Grafica de comportamiento:</p>

					<img src="imagenes/GraficaMezcla.jpg" width="600" height="400">
					
				</section>

				<section>
					
						<h2>Codigo</h2>
						<p>Para realizar la división de la lista se utiliza una función recursiva hasta obtener una lista de un solo numero.</p>
						<pre><code class="hljs" >
def ordenamientoPorMezcla (unaLista):
    print("Dividir ", unaLista)
    if len(unaLista)<2:
        return unaLista
    else:
        '''divido la tabla en dos'''
        mitad = len(unaLista)//2
        '''De la mitad tomo la parte derecha'''
        mitadIzquierda = unaLista[:mitad]
        '''De la mitad tomo la parte izquierda'''
        mitadDerecha = unaLista[mitad:]

        '''Utilizo recursividad para volver a dividir la lista'''
        izquierda = ordenamientoPorMezcla(mitadIzquierda)
        derecha = ordenamientoPorMezcla(mitadDerecha)

        return ordenar(izquierda, derecha)

					</code></pre>
					</section>
					<section>
						<p>Cuando la lista tiene un solo numero llama a la funcion <em>ordenar</em> para que los numeros se mezclen de forma ordenada en la lista. Consultando si la mitad izquierda </p>
						<pre><code class="hljs" >
def ordenar(mitadIzquierda, mitadDerecha):
    i, j = 0,0
    result = []

    while i < len(mitadIzquierda) and j < len(mitadDerecha):
        if mitadIzquierda[i] < mitadDerecha[j]:
                result.append(mitadIzquierda[i])
                i=i+1
        else:
                result.append(mitadDerecha[j])
                j=j+1

    result += mitadIzquierda[i:]
    result += mitadDerecha[j:]

    print("Mezclar ",result)
    return result       


					</code></pre>
					</section>



					
					
				</section>
				<section>
					
					<section>
				<h3>Algaritmo Rapido</h3>
				<p>Primero se selecciona un elemento de la lista a ordenar al que se le llamara <strong>pivote</strong>. Luego se recorre la lista y se situan los numeros menores a un costado de la lista y los mayores al otro lado.</p>
				<p>Como resultado se tienen dos sublistas. Para continuar con el procedimiento se deberá realizar el mismo paso anterior se elegira un pivote por cada lista y se obtendran dos sublistas.</p>
				<p>Cuando las listas resultantes tengan un solo elemento se tendra ordenada la lista principal.</p>
				

				</section>
				<section>
					<p>Se elige el primer pivote, que en este caso sera 54</p>
					<img src="imagenes/PrimerPivote.jpg" width="400" height="100">
					<p>Se eligen dos marcadores de posicion <em>marcaIzq</em> y <em>marcaDer</em> que se encontrarán al principio y final de los items restantes de la lista. El objetivo es mover los items que esten en el lado equivocado.</p>
					
				</section>
				<section>
					<p>Pasos</p>
					<img src="imagenes/Pasos.jpg" width="400" height="500">
					
				</section>
				<section>
					<h2>Rendimiento del algoritmo</h2>
					<p>La eficiencia del algoritmo depende de la eleccion del pivote.</p>
					<p>El mejor caso se produce cuando el pivote termina en el centro de la lista. Para este caso la formula del algoritmo sera:</p>

					<img src="imagenes/CasoOptimoRapido.jpg" width="100" height="50">
					
				</section>
				<section>
					<p>El peor caso se produce cuando el pivote se encuentra en un extremo de la lista. El orden de complejidad del algoritmo sera:</p>
					<img src="imagenes/CasoDesfavorableRapido.jpg" width="100" height="50">
				</section>
				<section>
					<p>Grafica de comportamiento:</p>

					<img src="imagenes/GraficaRapido.jpg" width="600" height="400">
					
				</section>
				</section>
				
				


				<section>
					
				<section>
				<h3>Algaritmo de selección</h3>
				<p>Primero se busca el elemento maximo de la lista y se intercambia por el ultimo.</p>
				<p>Luego se busca el siguiente numero maximo de la lista y se intercambia por el anteultimo.</p>
				<p>Y asi se continua hasta terminar con todos los elementos de la lista</p>
				<p>Su funcionamiento es un poco mejor que el del <em>algoritmo de burbuja</em> ya que realiza un solo intercambio por pasada</p>
				

				</section>
				
				<section>
					<p>Pasos</p>
					<img src="imagenes/PasosSeleccion.jpg" width="400" height="500">
					
				</section>
				<section>
					<h2>Rendimiento del algoritmo</h2>
					<p>La eficiencia del algoritmo depende de la eleccion del pivote.</p>
					<p>El mejor caso se produce cuando el pivote termina en el centro de la lista. Para este caso la formula del algoritmo sera:</p>

					<img src="imagenes/FormulaSeleccion.jpg" width="100" height="50">
					
				</section>
				

				<section>
					<p>Grafica de comportamiento:</p>

					<img src="imagenes/GraficaSeleccion.jpg" width="600" height="400">
					
				</section>
				
				</section>


				<section>
					<h2>Grafico de comparacion</h2>
				<img src="imagenes/GraficaTodos.jpg" width="700" height="450">
				</section>

				
				<section>
					<p>En el grafico se puede observar que el algoritmo con peor comportamiento es el de <em>Burbuja</em> seguido por el de <em>Insercion</em> y despues el de <em>Seleccion</em>. Los que tienen un comportamiento parecido son el de <em>Mezcla</em> y el <em>Rapido</em></p>
				</section>

				<section>
					<section>
					<h2>Algoritmo de Busqueda</h2>
				</section>

				<section>
					<h3>Busqueda Binaria</h3>
					<p>Se parte desde una lista ordenada, como la que devuelve del algoritmo anterior. Lo que realiza esta busqueda es consultar si el valor buscado se encuentra en la mitad, sino es asi consulta si el valor a buscar es mayor al que se encuentra en la mitad de la lista.</p>
					<p>Si es mayor se continuará la busqueda en la mitad con valores mayores. Realizando el procedimiento anterior.</p>
					<p>Ahora si el valor es menor la busqueda se realizara en la mitad con los valores menores</p>
				</section>
				<section>
						<p>Lo que devuelve la funcion es si el numero se encuentra o no en la lista. Recibirá por parametro la lista y el valor que se buscará en ella.</p>
						<pre><code class="hljs" >
def busquedaBinaria(arrayOrdenado, valorABuscar):
    '''Primero se busca por todo el array'''
    primeraPosicionArray = 0
    ultimaPosicionArray = len(arrayOrdenado) - 1
    encontrado = False

    '''Se va a repetir mientras la primera posicion del array sea menor igual a la ultima y que no se haya encontrado'''
    while primeraPosicionArray <= ultimaPosicionArray and not encontrado:
        '''Busco la posicion de la mitad del array'''
        posicionMitad = (primeraPosicionArray + ultimaPosicionArray) // 2
        '''Consulto si el valor de esta posición es igual al valor que se desea encontrar'''
        if arrayOrdenado[posicionMitad] == valorABuscar:
            encontrado = True


        else:
            '''Consulto si el valor a buscar es mayor al valor que se encuentra en la posición de la mitad del array'''
            if(valorABuscar > arrayOrdenado[posicionMitad]):
                '''Si es así solo tengo que buscar el valor de la mitad para arriba
                por lo que la primera posición ahora es la mitad mas uno'''
                primeraPosicionArray = posicionMitad + 1
            else:
                ultimaPosicionArray = posicionMitad - 1

    return encontrado



					</code></pre>
					</section>
				</section>

				<section>
					<h1>FIN</h1>
				</section>
				
				
				
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
